"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.injectPolyfillsLoader = injectPolyfillsLoader;

var _index = require("@open-wc/building-utils/dom5-fork/index.js");

var _parse = require("parse5");

var _path = _interopRequireDefault(require("path"));

var _deepmerge = _interopRequireDefault(require("deepmerge"));

var _polyfillsLoader = require("polyfills-loader");

var _systemjsTransformResolver = _interopRequireDefault(require("../browser-scripts/systemjs-transform-resolver.js"));

var _constants = require("../constants.js");

var _utils = require("./utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** @typedef {import('parse5').Document} DocumentAst */

/** @typedef {import('parse5').Node} NodeAst */

/** @typedef {import('./inject-polyfills-loader-types').InjectPolyfillsLoaderConfig} InjectPolyfillsLoaderConfig */

/** @typedef {import('polyfills-loader').File} File */

/** @typedef {import('polyfills-loader').GeneratedFile} GeneratedFile */

/** @typedef {import('polyfills-loader').PolyfillsConfig} PolyfillsConfig */

/** @type {PolyfillsConfig} */
const allPolyfills = {
  coreJs: true,
  regeneratorRuntime: true,
  fetch: true,
  webcomponents: true
};
/** @type {PolyfillsConfig} */

const allPolyfillsWithSystemjs = { ...allPolyfills,
  custom: [{
    name: 'systemjs',
    path: require.resolve('systemjs/dist/system.min.js'),
    initializer: _systemjsTransformResolver.default
  }]
};
/**
 * In max compatibility mode, we need to load the regenerator runtime on all browsers since
 * we're always compiling to es5.
 */

/** @type {PolyfillsConfig} */

const maxPolyfills = { ...allPolyfillsWithSystemjs,
  regeneratorRuntime: 'always'
};
/**
 * @param {InjectPolyfillsLoaderConfig} cfg
 * @returns {PolyfillsConfig}
 */

function getPolyfillsConfig(cfg) {
  switch (cfg.compatibilityMode) {
    case _constants.compatibilityModes.MAX:
      return maxPolyfills;

    case _constants.compatibilityModes.MIN:
      return allPolyfills;

    case _constants.compatibilityModes.AUTO:
    case _constants.compatibilityModes.ALWAYS:
      if (cfg.compatibilityMode === _constants.compatibilityModes.AUTO && cfg.uaCompat.modern) {
        return {};
      }

      if (cfg.uaCompat.supportsEsm) {
        return allPolyfills;
      }

      return allPolyfillsWithSystemjs;

    default:
      return {};
  }
}
/**
 * @param {InjectPolyfillsLoaderConfig} cfg
 * @param {DocumentAst} documentAst
 */


function findScripts(cfg, documentAst) {
  const scriptNodes = (0, _polyfillsLoader.findJsScripts)(documentAst, cfg.polyfillsLoaderConfig && cfg.polyfillsLoaderConfig.exclude);
  /** @type {File[]}  */

  const files = [];
  /** @type {GeneratedFile[]} */

  const inlineScripts = [];
  const inlineScriptNodes = [];
  scriptNodes.forEach((scriptNode, i) => {
    const type = (0, _polyfillsLoader.getScriptFileType)(scriptNode);
    let src = (0, _index.getAttribute)(scriptNode, 'src');

    if (!src) {
      src = `inline-script-${i}.js?source=${encodeURIComponent(cfg.indexUrl)}`;
      inlineScripts.push({
        path: src,
        type,
        content: (0, _index.getTextContent)(scriptNode)
      });
      inlineScriptNodes.push(scriptNode);
    }

    files.push({
      type,
      path: src
    });
  });
  return {
    files,
    inlineScripts,
    scriptNodes,
    inlineScriptNodes
  };
}
/**
 * @param {PolyfillsConfig} polyfills
 */


function hasPolyfills(polyfills) {
  const {
    hash,
    custom,
    ...rest
  } = polyfills;
  return custom && custom.length > 0 || Object.values(rest).some(v => v !== false);
}
/**
 * @param {InjectPolyfillsLoaderConfig} cfg
 * @param {NodeAst[]} inlineScriptNodes
 */


async function transformInlineScripts(cfg, inlineScriptNodes) {
  const asyncTransforms = [];

  for (const scriptNode of inlineScriptNodes) {
    // we need to refer to an actual file for node resolve to work properly
    const filePath = cfg.indexFilePath.endsWith(_path.default.sep) ? _path.default.join(cfg.indexFilePath, 'index.html') : cfg.indexFilePath;
    const asyncTransform = cfg.transformJs({
      filePath,
      uaCompat: cfg.uaCompat,
      code: (0, _index.getTextContent)(scriptNode),
      transformModule: false
    }).then(code => {
      (0, _index.setTextContent)(scriptNode, code);
    });
    asyncTransforms.push(asyncTransform);
  }

  await Promise.all(asyncTransforms);
}
/**
 * transforms index.html, extracting any modules and import maps and adds them back
 * with the appropriate polyfills, shims and a script loader so that they can be loaded
 * at the right time
 *
 * @param {InjectPolyfillsLoaderConfig} cfg
 * @returns {Promise<{ indexHTML: string, inlineScripts: GeneratedFile[], polyfills: GeneratedFile[] }>}
 */


async function injectPolyfillsLoader(cfg) {
  const polyfillModules = [_constants.compatibilityModes.AUTO, _constants.compatibilityModes.ALWAYS].includes(cfg.compatibilityMode) && !cfg.uaCompat.supportsEsm || cfg.compatibilityMode === _constants.compatibilityModes.MAX;

  const documentAst = (0, _parse.parse)(cfg.htmlString);
  const {
    files,
    inlineScripts,
    scriptNodes,
    inlineScriptNodes
  } = findScripts(cfg, documentAst);
  const polyfillsConfig = getPolyfillsConfig(cfg);
  const polyfillsLoaderConfig = (0, _deepmerge.default)({
    modern: {
      files: files.map(f => ({ ...f,
        type: f.type === _polyfillsLoader.fileTypes.MODULE && polyfillModules ? _polyfillsLoader.fileTypes.SYSTEMJS : f.type
      }))
    },
    polyfills: polyfillsConfig
  }, cfg.polyfillsLoaderConfig || {});

  if (!hasPolyfills(polyfillsLoaderConfig.polyfills) && !polyfillModules) {
    // no polyfils module polyfills, so we don't need to inject a loader
    if (inlineScripts && inlineScripts.length > 0) {
      // there are inline scripts, we need to transform them
      // transformInlineScripts mutates documentAst
      await transformInlineScripts(cfg, inlineScriptNodes);
      return {
        indexHTML: (0, _parse.serialize)(documentAst),
        inlineScripts,
        polyfills: []
      };
    }

    return {
      indexHTML: cfg.htmlString,
      inlineScripts: [],
      polyfills: []
    };
  } // we will inject a loader, so we need to remove the inline script nodes as the loader
  // will include them as virtual modules


  for (const scriptNode of scriptNodes) {
    // remove script from document
    (0, _index.remove)(scriptNode);
  }

  (0, _utils.logDebug)('[polyfills-loader] config', polyfillsLoaderConfig);
  const result = (0, _polyfillsLoader.injectPolyfillsLoader)((0, _parse.serialize)(documentAst), polyfillsLoaderConfig);
  (0, _utils.logDebug)('[polyfills-loader] generated polyfills: ', result.polyfillFiles.map(p => ({ ...p,
    content: '[stripped]'
  })));
  (0, _utils.logDebug)('Inline scripts generated by polyfills-loader', inlineScripts.map(p => ({ ...p,
    content: '[stripped]'
  })));
  return {
    indexHTML: result.htmlString,
    inlineScripts,
    polyfills: result.polyfillFiles
  };
}